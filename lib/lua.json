{
  "blacklist_client.lua": "local blacklist = ARGV[num_static_argv + 1]\r\n\r\nif redis.call('zscore', client_last_seen_key, blacklist) then\r\n  redis.call('zadd', client_last_seen_key, 0, blacklist)\r\nend\r\n\r\n\r\nreturn {}\r\n",
  "check.lua": "local weight = tonumber(ARGV[num_static_argv + 1])\r\n\r\nlocal capacity = process_tick(now, false)['capacity']\r\nlocal nextRequest = tonumber(redis.call('hget', settings_key, 'nextRequest'))\r\n\r\nreturn conditions_check(capacity, weight) and nextRequest - now <= 0\r\n",
  "conditions_check.lua": "local conditions_check = function (capacity, weight)\r\n  return capacity == nil or weight <= capacity\r\nend\r\n",
  "current_reservoir.lua": "return process_tick(now, false)['reservoir']\r\n",
  "done.lua": "process_tick(now, false)\r\n\r\nreturn tonumber(redis.call('hget', settings_key, 'done'))\r\n",
  "free.lua": "local index = ARGV[num_static_argv + 1]\r\n\r\nredis.call('zadd', job_expirations_key, 0, index)\r\n\r\nreturn process_tick(now, false)['running']\r\n",
  "get_time.lua": "redis.replicate_commands()\r\n\r\nlocal get_time = function ()\r\n  local time = redis.call('time')\r\n\r\n  return tonumber(time[1]..string.sub(time[2], 1, 3))\r\nend\r\n",
  "group_check.lua": "return not (redis.call('exists', settings_key) == 1)\r\n",
  "heartbeat.lua": "process_tick(now, true)\r\n",
  "increment_reservoir.lua": "local incr = tonumber(ARGV[num_static_argv + 1])\r\n\r\nredis.call('hincrby', settings_key, 'reservoir', incr)\r\n\r\nlocal reservoir = process_tick(now, true)['reservoir']\r\n\r\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\r\nrefresh_expiration(0, 0, groupTimeout)\r\n\r\nreturn reservoir\r\n",
  "init.lua": "local clear = tonumber(ARGV[num_static_argv + 1])\r\nlocal limiter_version = ARGV[num_static_argv + 2]\r\nlocal num_local_argv = num_static_argv + 2\r\n\r\nif clear == 1 then\r\n  redis.call('del', unpack(KEYS))\r\nend\r\n\r\nif redis.call('exists', settings_key) == 0 then\r\n  -- Create\r\n  local args = {'hmset', settings_key}\r\n\r\n  for i = num_local_argv + 1, #ARGV do\r\n    table.insert(args, ARGV[i])\r\n  end\r\n\r\n  redis.call(unpack(args))\r\n  redis.call('hmset', settings_key,\r\n    'nextRequest', now,\r\n    'lastReservoirRefresh', now,\r\n    'lastReservoirIncrease', now,\r\n    'running', 0,\r\n    'done', 0,\r\n    'unblockTime', 0,\r\n    'capacityPriorityCounter', 0\r\n  )\r\n\r\nelse\r\n  -- Apply migrations\r\n  local settings = redis.call('hmget', settings_key,\r\n    'id',\r\n    'version'\r\n  )\r\n  local id = settings[1]\r\n  local current_version = settings[2]\r\n\r\n  if current_version ~= limiter_version then\r\n    local version_digits = {}\r\n    for k, v in string.gmatch(current_version, \"([^.]+)\") do\r\n      table.insert(version_digits, tonumber(k))\r\n    end\r\n\r\n    -- 2.10.0\r\n    if version_digits[2] < 10 then\r\n      redis.call('hsetnx', settings_key, 'reservoirRefreshInterval', '')\r\n      redis.call('hsetnx', settings_key, 'reservoirRefreshAmount', '')\r\n      redis.call('hsetnx', settings_key, 'lastReservoirRefresh', '')\r\n      redis.call('hsetnx', settings_key, 'done', 0)\r\n      redis.call('hset', settings_key, 'version', '2.10.0')\r\n    end\r\n\r\n    -- 2.11.1\r\n    if version_digits[2] < 11 or (version_digits[2] == 11 and version_digits[3] < 1) then\r\n      if redis.call('hstrlen', settings_key, 'lastReservoirRefresh') == 0 then\r\n        redis.call('hmset', settings_key,\r\n          'lastReservoirRefresh', now,\r\n          'version', '2.11.1'\r\n        )\r\n      end\r\n    end\r\n\r\n    -- 2.14.0\r\n    if version_digits[2] < 14 then\r\n      local old_running_key = 'b_'..id..'_running'\r\n      local old_executing_key = 'b_'..id..'_executing'\r\n\r\n      if redis.call('exists', old_running_key) == 1 then\r\n        redis.call('rename', old_running_key, job_weights_key)\r\n      end\r\n      if redis.call('exists', old_executing_key) == 1 then\r\n        redis.call('rename', old_executing_key, job_expirations_key)\r\n      end\r\n      redis.call('hset', settings_key, 'version', '2.14.0')\r\n    end\r\n\r\n    -- 2.15.2\r\n    if version_digits[2] < 15 or (version_digits[2] == 15 and version_digits[3] < 2) then\r\n      redis.call('hsetnx', settings_key, 'capacityPriorityCounter', 0)\r\n      redis.call('hset', settings_key, 'version', '2.15.2')\r\n    end\r\n\r\n    -- 2.17.0\r\n    if version_digits[2] < 17 then\r\n      redis.call('hsetnx', settings_key, 'clientTimeout', 10000)\r\n      redis.call('hset', settings_key, 'version', '2.17.0')\r\n    end\r\n\r\n    -- 2.18.0\r\n    if version_digits[2] < 18 then\r\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseInterval', '')\r\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseAmount', '')\r\n      redis.call('hsetnx', settings_key, 'reservoirIncreaseMaximum', '')\r\n      redis.call('hsetnx', settings_key, 'lastReservoirIncrease', now)\r\n      redis.call('hset', settings_key, 'version', '2.18.0')\r\n    end\r\n\r\n  end\r\n\r\n  process_tick(now, false)\r\nend\r\n\r\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\r\nrefresh_expiration(0, 0, groupTimeout)\r\n\r\nreturn {}\r\n",
  "process_tick.lua": "local process_tick = function (now, always_publish)\r\n\r\n  local compute_capacity = function (maxConcurrent, running, reservoir)\r\n    if maxConcurrent ~= nil and reservoir ~= nil then\r\n      return math.min((maxConcurrent - running), reservoir)\r\n    elseif maxConcurrent ~= nil then\r\n      return maxConcurrent - running\r\n    elseif reservoir ~= nil then\r\n      return reservoir\r\n    else\r\n      return nil\r\n    end\r\n  end\r\n\r\n  local settings = redis.call('hmget', settings_key,\r\n    'id',\r\n    'maxConcurrent',\r\n    'running',\r\n    'reservoir',\r\n    'reservoirRefreshInterval',\r\n    'reservoirRefreshAmount',\r\n    'lastReservoirRefresh',\r\n    'reservoirIncreaseInterval',\r\n    'reservoirIncreaseAmount',\r\n    'reservoirIncreaseMaximum',\r\n    'lastReservoirIncrease',\r\n    'capacityPriorityCounter',\r\n    'clientTimeout'\r\n  )\r\n  local id = settings[1]\r\n  local maxConcurrent = tonumber(settings[2])\r\n  local running = tonumber(settings[3])\r\n  local reservoir = tonumber(settings[4])\r\n  local reservoirRefreshInterval = tonumber(settings[5])\r\n  local reservoirRefreshAmount = tonumber(settings[6])\r\n  local lastReservoirRefresh = tonumber(settings[7])\r\n  local reservoirIncreaseInterval = tonumber(settings[8])\r\n  local reservoirIncreaseAmount = tonumber(settings[9])\r\n  local reservoirIncreaseMaximum = tonumber(settings[10])\r\n  local lastReservoirIncrease = tonumber(settings[11])\r\n  local capacityPriorityCounter = tonumber(settings[12])\r\n  local clientTimeout = tonumber(settings[13])\r\n\r\n  local initial_capacity = compute_capacity(maxConcurrent, running, reservoir)\r\n\r\n  --\r\n  -- Process 'running' changes\r\n  --\r\n  local expired = redis.call('zrangebyscore', job_expirations_key, '-inf', '('..now)\r\n\r\n  if #expired > 0 then\r\n    redis.call('zremrangebyscore', job_expirations_key, '-inf', '('..now)\r\n\r\n    local flush_batch = function (batch, acc)\r\n      local weights = redis.call('hmget', job_weights_key, unpack(batch))\r\n                      redis.call('hdel',  job_weights_key, unpack(batch))\r\n      local clients = redis.call('hmget', job_clients_key, unpack(batch))\r\n                      redis.call('hdel',  job_clients_key, unpack(batch))\r\n\r\n      -- Calculate sum of removed weights\r\n      for i = 1, #weights do\r\n        acc['total'] = acc['total'] + (tonumber(weights[i]) or 0)\r\n      end\r\n\r\n      -- Calculate sum of removed weights by client\r\n      local client_weights = {}\r\n      for i = 1, #clients do\r\n        local removed = tonumber(weights[i]) or 0\r\n        if removed > 0 then\r\n          acc['client_weights'][clients[i]] = (acc['client_weights'][clients[i]] or 0) + removed\r\n        end\r\n      end\r\n    end\r\n\r\n    local acc = {\r\n      ['total'] = 0,\r\n      ['client_weights'] = {}\r\n    }\r\n    local batch_size = 1000\r\n\r\n    -- Compute changes to Zsets and apply changes to Hashes\r\n    for i = 1, #expired, batch_size do\r\n      local batch = {}\r\n      for j = i, math.min(i + batch_size - 1, #expired) do\r\n        table.insert(batch, expired[j])\r\n      end\r\n\r\n      flush_batch(batch, acc)\r\n    end\r\n\r\n    -- Apply changes to Zsets\r\n    if acc['total'] > 0 then\r\n      redis.call('hincrby', settings_key, 'done', acc['total'])\r\n      running = tonumber(redis.call('hincrby', settings_key, 'running', -acc['total']))\r\n    end\r\n\r\n    for client, weight in pairs(acc['client_weights']) do\r\n      redis.call('zincrby', client_running_key, -weight, client)\r\n    end\r\n  end\r\n\r\n  --\r\n  -- Process 'reservoir' changes\r\n  --\r\n  local reservoirRefreshActive = reservoirRefreshInterval ~= nil and reservoirRefreshAmount ~= nil\r\n  if reservoirRefreshActive and now >= lastReservoirRefresh + reservoirRefreshInterval then\r\n    reservoir = reservoirRefreshAmount\r\n    redis.call('hmset', settings_key,\r\n      'reservoir', reservoir,\r\n      'lastReservoirRefresh', now\r\n    )\r\n  end\r\n\r\n  local reservoirIncreaseActive = reservoirIncreaseInterval ~= nil and reservoirIncreaseAmount ~= nil\r\n  if reservoirIncreaseActive and now >= lastReservoirIncrease + reservoirIncreaseInterval then\r\n    local num_intervals = math.floor((now - lastReservoirIncrease) / reservoirIncreaseInterval)\r\n    local incr = reservoirIncreaseAmount * num_intervals\r\n    if reservoirIncreaseMaximum ~= nil then\r\n      incr = math.min(incr, reservoirIncreaseMaximum - (reservoir or 0))\r\n    end\r\n    if incr > 0 then\r\n      reservoir = (reservoir or 0) + incr\r\n    end\r\n    redis.call('hmset', settings_key,\r\n      'reservoir', reservoir,\r\n      'lastReservoirIncrease', lastReservoirIncrease + (num_intervals * reservoirIncreaseInterval)\r\n    )\r\n  end\r\n\r\n  --\r\n  -- Clear unresponsive clients\r\n  --\r\n  local unresponsive = redis.call('zrangebyscore', client_last_seen_key, '-inf', (now - clientTimeout))\r\n  local unresponsive_lookup = {}\r\n  local terminated_clients = {}\r\n  for i = 1, #unresponsive do\r\n    unresponsive_lookup[unresponsive[i]] = true\r\n    if tonumber(redis.call('zscore', client_running_key, unresponsive[i])) == 0 then\r\n      table.insert(terminated_clients, unresponsive[i])\r\n    end\r\n  end\r\n  if #terminated_clients > 0 then\r\n    redis.call('zrem', client_running_key,         unpack(terminated_clients))\r\n    redis.call('hdel', client_num_queued_key,      unpack(terminated_clients))\r\n    redis.call('zrem', client_last_registered_key, unpack(terminated_clients))\r\n    redis.call('zrem', client_last_seen_key,       unpack(terminated_clients))\r\n  end\r\n\r\n  --\r\n  -- Broadcast capacity changes\r\n  --\r\n  local final_capacity = compute_capacity(maxConcurrent, running, reservoir)\r\n\r\n  if always_publish or (initial_capacity ~= nil and final_capacity == nil) then\r\n    -- always_publish or was not unlimited, now unlimited\r\n    redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\r\n\r\n  elseif initial_capacity ~= nil and final_capacity ~= nil and final_capacity > initial_capacity then\r\n    -- capacity was increased\r\n    -- send the capacity message to the limiter having the lowest number of running jobs\r\n    -- the tiebreaker is the limiter having not registered a job in the longest time\r\n\r\n    local lowest_concurrency_value = nil\r\n    local lowest_concurrency_clients = {}\r\n    local lowest_concurrency_last_registered = {}\r\n    local client_concurrencies = redis.call('zrange', client_running_key, 0, -1, 'withscores')\r\n\r\n    for i = 1, #client_concurrencies, 2 do\r\n      local client = client_concurrencies[i]\r\n      local concurrency = tonumber(client_concurrencies[i+1])\r\n\r\n      if (\r\n        lowest_concurrency_value == nil or lowest_concurrency_value == concurrency\r\n      ) and (\r\n        not unresponsive_lookup[client]\r\n      ) and (\r\n        tonumber(redis.call('hget', client_num_queued_key, client)) > 0\r\n      ) then\r\n        lowest_concurrency_value = concurrency\r\n        table.insert(lowest_concurrency_clients, client)\r\n        local last_registered = tonumber(redis.call('zscore', client_last_registered_key, client))\r\n        table.insert(lowest_concurrency_last_registered, last_registered)\r\n      end\r\n    end\r\n\r\n    if #lowest_concurrency_clients > 0 then\r\n      local position = 1\r\n      local earliest = lowest_concurrency_last_registered[1]\r\n\r\n      for i,v in ipairs(lowest_concurrency_last_registered) do\r\n        if v < earliest then\r\n          position = i\r\n          earliest = v\r\n        end\r\n      end\r\n\r\n      local next_client = lowest_concurrency_clients[position]\r\n      redis.call('publish', 'b_'..id,\r\n        'capacity-priority:'..(final_capacity or '')..\r\n        ':'..next_client..\r\n        ':'..capacityPriorityCounter\r\n      )\r\n      redis.call('hincrby', settings_key, 'capacityPriorityCounter', '1')\r\n    else\r\n      redis.call('publish', 'b_'..id, 'capacity:'..(final_capacity or ''))\r\n    end\r\n  end\r\n\r\n  return {\r\n    ['capacity'] = final_capacity,\r\n    ['running'] = running,\r\n    ['reservoir'] = reservoir\r\n  }\r\nend\r\n",
  "queued.lua": "local clientTimeout = tonumber(redis.call('hget', settings_key, 'clientTimeout'))\r\nlocal valid_clients = redis.call('zrangebyscore', client_last_seen_key, (now - clientTimeout), 'inf')\r\nlocal client_queued = redis.call('hmget', client_num_queued_key, unpack(valid_clients))\r\n\r\nlocal sum = 0\r\nfor i = 1, #client_queued do\r\n  sum = sum + tonumber(client_queued[i])\r\nend\r\n\r\nreturn sum\r\n",
  "refresh_expiration.lua": "local refresh_expiration = function (now, nextRequest, groupTimeout)\r\n\r\n  if groupTimeout ~= nil then\r\n    local ttl = (nextRequest + groupTimeout) - now\r\n\r\n    for i = 1, #KEYS do\r\n      redis.call('pexpire', KEYS[i], ttl)\r\n    end\r\n  end\r\n\r\nend\r\n",
  "refs.lua": "local settings_key = KEYS[1]\r\nlocal job_weights_key = KEYS[2]\r\nlocal job_expirations_key = KEYS[3]\r\nlocal job_clients_key = KEYS[4]\r\nlocal client_running_key = KEYS[5]\r\nlocal client_num_queued_key = KEYS[6]\r\nlocal client_last_registered_key = KEYS[7]\r\nlocal client_last_seen_key = KEYS[8]\r\n\r\nlocal now = tonumber(ARGV[1])\r\nlocal client = ARGV[2]\r\n\r\nlocal num_static_argv = 2\r\n",
  "register.lua": "local index = ARGV[num_static_argv + 1]\r\nlocal weight = tonumber(ARGV[num_static_argv + 2])\r\nlocal expiration = tonumber(ARGV[num_static_argv + 3])\r\n\r\nlocal state = process_tick(now, false)\r\nlocal capacity = state['capacity']\r\nlocal reservoir = state['reservoir']\r\n\r\nlocal settings = redis.call('hmget', settings_key,\r\n  'nextRequest',\r\n  'minTime',\r\n  'groupTimeout'\r\n)\r\nlocal nextRequest = tonumber(settings[1])\r\nlocal minTime = tonumber(settings[2])\r\nlocal groupTimeout = tonumber(settings[3])\r\n\r\nif conditions_check(capacity, weight) then\r\n\r\n  redis.call('hincrby', settings_key, 'running', weight)\r\n  redis.call('hset', job_weights_key, index, weight)\r\n  if expiration ~= nil then\r\n    redis.call('zadd', job_expirations_key, now + expiration, index)\r\n  end\r\n  redis.call('hset', job_clients_key, index, client)\r\n  redis.call('zincrby', client_running_key, weight, client)\r\n  redis.call('hincrby', client_num_queued_key, client, -1)\r\n  redis.call('zadd', client_last_registered_key, now, client)\r\n\r\n  local wait = math.max(nextRequest - now, 0)\r\n  local newNextRequest = now + wait + minTime\r\n\r\n  if reservoir == nil then\r\n    redis.call('hset', settings_key,\r\n      'nextRequest', newNextRequest\r\n    )\r\n  else\r\n    reservoir = reservoir - weight\r\n    redis.call('hmset', settings_key,\r\n      'reservoir', reservoir,\r\n      'nextRequest', newNextRequest\r\n    )\r\n  end\r\n\r\n  refresh_expiration(now, newNextRequest, groupTimeout)\r\n\r\n  return {true, wait, reservoir}\r\n\r\nelse\r\n  return {false}\r\nend\r\n",
  "register_client.lua": "local queued = tonumber(ARGV[num_static_argv + 1])\r\n\r\n-- Could have been re-registered concurrently\r\nif not redis.call('zscore', client_last_seen_key, client) then\r\n  redis.call('zadd', client_running_key, 0, client)\r\n  redis.call('hset', client_num_queued_key, client, queued)\r\n  redis.call('zadd', client_last_registered_key, 0, client)\r\nend\r\n\r\nredis.call('zadd', client_last_seen_key, now, client)\r\n\r\nreturn {}\r\n",
  "running.lua": "return process_tick(now, false)['running']\r\n",
  "submit.lua": "local queueLength = tonumber(ARGV[num_static_argv + 1])\r\nlocal weight = tonumber(ARGV[num_static_argv + 2])\r\n\r\nlocal capacity = process_tick(now, false)['capacity']\r\n\r\nlocal settings = redis.call('hmget', settings_key,\r\n  'id',\r\n  'maxConcurrent',\r\n  'highWater',\r\n  'nextRequest',\r\n  'strategy',\r\n  'unblockTime',\r\n  'penalty',\r\n  'minTime',\r\n  'groupTimeout'\r\n)\r\nlocal id = settings[1]\r\nlocal maxConcurrent = tonumber(settings[2])\r\nlocal highWater = tonumber(settings[3])\r\nlocal nextRequest = tonumber(settings[4])\r\nlocal strategy = tonumber(settings[5])\r\nlocal unblockTime = tonumber(settings[6])\r\nlocal penalty = tonumber(settings[7])\r\nlocal minTime = tonumber(settings[8])\r\nlocal groupTimeout = tonumber(settings[9])\r\n\r\nif maxConcurrent ~= nil and weight > maxConcurrent then\r\n  return redis.error_reply('OVERWEIGHT:'..weight..':'..maxConcurrent)\r\nend\r\n\r\nlocal reachedHWM = (highWater ~= nil and queueLength == highWater\r\n  and not (\r\n    conditions_check(capacity, weight)\r\n    and nextRequest - now <= 0\r\n  )\r\n)\r\n\r\nlocal blocked = strategy == 3 and (reachedHWM or unblockTime >= now)\r\n\r\nif blocked then\r\n  local computedPenalty = penalty\r\n  if computedPenalty == nil then\r\n    if minTime == 0 then\r\n      computedPenalty = 5000\r\n    else\r\n      computedPenalty = 15 * minTime\r\n    end\r\n  end\r\n\r\n  local newNextRequest = now + computedPenalty + minTime\r\n\r\n  redis.call('hmset', settings_key,\r\n    'unblockTime', now + computedPenalty,\r\n    'nextRequest', newNextRequest\r\n  )\r\n\r\n  local clients_queued_reset = redis.call('hkeys', client_num_queued_key)\r\n  local queued_reset = {}\r\n  for i = 1, #clients_queued_reset do\r\n    table.insert(queued_reset, clients_queued_reset[i])\r\n    table.insert(queued_reset, 0)\r\n  end\r\n  redis.call('hmset', client_num_queued_key, unpack(queued_reset))\r\n\r\n  redis.call('publish', 'b_'..id, 'blocked:')\r\n\r\n  refresh_expiration(now, newNextRequest, groupTimeout)\r\nend\r\n\r\nif not blocked and not reachedHWM then\r\n  redis.call('hincrby', client_num_queued_key, client, 1)\r\nend\r\n\r\nreturn {reachedHWM, blocked, strategy}\r\n",
  "update_settings.lua": "local args = {'hmset', settings_key}\r\n\r\nfor i = num_static_argv + 1, #ARGV do\r\n  table.insert(args, ARGV[i])\r\nend\r\n\r\nredis.call(unpack(args))\r\n\r\nprocess_tick(now, true)\r\n\r\nlocal groupTimeout = tonumber(redis.call('hget', settings_key, 'groupTimeout'))\r\nrefresh_expiration(0, 0, groupTimeout)\r\n\r\nreturn {}\r\n",
  "validate_client.lua": "if not redis.call('zscore', client_last_seen_key, client) then\r\n  return redis.error_reply('UNKNOWN_CLIENT')\r\nend\r\n\r\nredis.call('zadd', client_last_seen_key, now, client)\r\n",
  "validate_keys.lua": "if not (redis.call('exists', settings_key) == 1) then\r\n  return redis.error_reply('SETTINGS_KEY_NOT_FOUND')\r\nend\r\n"
}
